# ~/.aliases - Enhanced Command Aliases & Functions
# Sourced by .zshrc for all interactive shells
#
# ALIAS DESCRIPTIONS SYSTEM:
# To enable startup tips, add a comment with # after your alias:
#   alias myalias='command'  # Description for startup tips
# The show-alias-tips.sh script extracts these for random display
# ================================================================

# Easier navigation: .., ..., ...., ....., ~ and -
alias ..="cd .."  # Go up one directory
alias ...="cd ../.."  # Go up two directories
alias ....="cd ../../.."  # Go up three directories
alias .....="cd ../../../.."  # Go up four directories

# Vim
# alias vim='mvim '

alias g="git"  # Quick git command access

colorflag="-G"

# Modern ls replacement with eza (with fallback to ls)
if command -v eza &> /dev/null; then
    alias ls='eza --icons --group-directories-first'  # Modern ls with icons
    alias l='eza -l --icons --group-directories-first'  # Long format with icons
    alias la='eza -la --icons --group-directories-first --git'  # Long format with hidden files and git status
    alias lsd='eza -lD --icons'  # Show only directories
else
    # Fallback to traditional ls
    alias l="ls -lF ${colorflag}"
    alias la="ls -laF ${colorflag}"
    alias lsd="ls -lF ${colorflag} | rg '^d'"
    alias ls="ls ${colorflag}"
fi
export LS_COLORS='no=00:fi=00:di=01;34:ln=01;36:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arj=01;31:*.taz=01;31:*.lzh=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.gz=01;31:*.bz2=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.avi=01;35:*.fli=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.ogg=01;35:*.mp3=01;35:*.wav=01;35:'

# Enable aliases to be sudo’ed
alias sudo='sudo '

# Stopwatch
# Live stopwatch timer with real-time elapsed display
timer() {
    local start_time=$(date +%s)
    local start_display=$(date +"%H:%M:%S")

    echo "⏱️  Timer started at $start_display"
    echo "Press Enter to stop..."
    echo ""

    # Disable job control notifications
    setopt LOCAL_OPTIONS NO_NOTIFY NO_MONITOR

    # Start background process to update time display
    while true; do
        local current=$(date +%s)
        local elapsed=$((current - start_time))
        local hours=$((elapsed / 3600))
        local minutes=$(((elapsed % 3600) / 60))
        local seconds=$((elapsed % 60))

        printf "\r🕐 Elapsed: %02d:%02d:%02d" $hours $minutes $seconds
        sleep 1
    done &

    local bg_pid=$!

    # Wait for Enter
    read

    # Kill background process and show final time
    kill $bg_pid 2>/dev/null
    wait $bg_pid 2>/dev/null
    local end_time=$(date +%s)
    local total_elapsed=$((end_time - start_time))
    local final_hours=$((total_elapsed / 3600))
    local final_minutes=$(((total_elapsed % 3600) / 60))
    local final_seconds=$((total_elapsed % 60))

    printf "\n⏹️  Final time: %02d:%02d:%02d (stopped at %s)\n" $final_hours $final_minutes $final_seconds "$(date +%H:%M:%S)"
}

# IP addresses
alias ip="dig +short myip.opendns.com @resolver1.opendns.com"
alias localip="ipconfig getifaddr en0"
alias ips="ifconfig -a | rg -o 'inet6? (addr:)?\s?((([0-9]+\.){3}[0-9]+)|[a-fA-F0-9:]+)' | sed 's/inet6* (addr:)* *//'"

# Empty the Trash on all mounted volumes and the main HDD
# Also, clear Apple’s System Logs to improve shell startup speed
alias emptytrash="sudo rm -rfv /Volumes/*/.Trashes; sudo rm -rfv ~/.Trash; sudo rm -rfv /private/var/log/asl/*.asl"  # Empty all trash and logs

# Show/hide hidden files in Finder
alias show="defaults write com.apple.finder AppleShowAllFiles -bool true && killall Finder"
alias hide="defaults write com.apple.finder AppleShowAllFiles -bool false && killall Finder"

# Hide/show all desktop icons (useful when presenting)
alias hidedesktop="defaults write com.apple.finder CreateDesktop -bool false && killall Finder"
alias showdesktop="defaults write com.apple.finder CreateDesktop -bool true && killall Finder"

# Kill all the tabs in Chrome to free up memory
# [C] explained: http://www.commandlinefu.com/commands/view/402/exclude-grep-from-your-grepped-output-of-ps-alias-included-in-description
alias chromekill="ps ux | rg '[C]hrome Helper --type=renderer' | rg -v extension-process | tr -s ' ' | cut -d ' ' -f2 | xargs kill"  # Kill Chrome helper processes

# Lock the screen (when going AFK)
alias afk="osascript -e 'tell application \"System Events\" to keystroke \"q\" using {command down, control down}' && pmset sleepnow"  # Lock screen and sleep

# Enhanced cat with syntax highlighting (with fallback)
if command -v bat &> /dev/null; then
    alias cat='bat --paging=never --style=numbers,changes --theme=Dracula'
    alias batcat='bat'  # Keep original bat command available
fi

# Reload the shell (i.e. invoke as a login shell)
alias reload="exec $SHELL -l"

# Flush DNS
alias flushDNS="sudo killall -HUP mDNSResponder"  # Flush DNS cache

# AI-friendly aliases and functions
# Quick directory and file operations
alias ll='eza -la --icons --group-directories-first --git'  # Detailed list with git status
alias lt='eza --tree --level=2 --icons --all'              # Tree view (2 levels) including hidden files
alias lg='lazygit'                                           # Quick git UI

# Development workflow shortcuts
alias dev='cd "$DEV_DIR"'  # Quick access to dev directory
alias dots='cd ~/dotfiles'  # Quick access to dotfiles
alias src='cd "$DEV_DIR" && ls'  # Go to code dir and list
alias j='just'  # Quick just command runner
alias refresh='echo "🔄 Refreshing shell configuration..." && zsh -c "source ~/.zshenv; source ~/.zshrc; source ~/.aliases; echo \"✅ Configuration loaded (ZSHRC_LOADED: \$ZSHRC_LOADED)\"; dotfiles-health"'  # Reload shell configuration and run health check
alias clear-shell-cache='rm -f ~/.cache/*-completion.zsh ~/.cache/*-init.zsh && echo "🧹 Shell completion caches cleared"'  # Clear cached completions

# System and tool integration
alias csvlint="/opt/homebrew/lib/ruby/gems/3.4.0/bin/csvlint"  # CSV validation tool
alias python=python3  # Use Python 3 by default
alias uvr='uv run python'  # Quick uv run python shortcut

# Python package management - interactive pip replacement
pip() {
    if [[ $# -eq 0 ]]; then
        echo "💡 Python package management with uv:"
        echo "  uv add <package>        # Add to current project"
        echo "  uv tool install <pkg>   # Install global tool"
        echo "  uvr --with <pkg> ...    # One-off script usage"
        return 1
    fi

    if [[ "$1" == "install" ]]; then
        shift  # Remove 'install' from arguments
        echo "💡 Install '${*}' globally as a tool? (y/n)"
        read -r response
        if [[ "$response" =~ ^[Yy]$ ]]; then
            uv tool install "$@"
        else
            echo ""
            echo "💡 Alternatives:"
            echo "  uv add ${*}              # Add to current project"
            echo "  uvr --with ${*} script   # One-off usage"
        fi
    else
        echo "💡 Use uv commands instead:"
        echo "  uv add <package>        # Add to project"
        echo "  uv tool install <pkg>   # Global tool"
    fi
}

alias pip3='pip'  # Same interactive function for pip3

# Meta-aliases for discovering other tools' aliases
alias git-aliases='git config --get-regexp "^alias\." | sed "s/^alias\.//"'  # Show all git aliases
alias npm-aliases='npm run --silent'  # Show npm script aliases
alias docker-aliases='echo "Docker aliases are in: docker --help"'  # Docker command reference

# Quick environment info for AI context
alias env-info='echo "🖥️  Environment Info:"; echo "Shell: $SHELL ($ZSH_VERSION)"; echo "OS: $(uname -s) $(uname -r)"; echo "Node: $(node --version 2>/dev/null || echo "not installed")"; echo "Go: $(go version 2>/dev/null | cut -d" " -f3 || echo "not installed")"; echo "Rust: $(rustc --version 2>/dev/null | cut -d" " -f2 || echo "not installed")"; echo "Python: $(python3 --version 2>/dev/null || echo "not installed")"; echo "Editor: $EDITOR"; echo "PWD: $(pwd)"'  # Show development environment summary

# AI-friendly file operations (using modern tools)
alias recent='find . -type f -mtime -1 -not -path "*/.*" | head -10'  # Recent files (1 day)
alias biggest='du -sh * | sort -rh | head -10'                        # Largest files/dirs
alias count='find . -type f | wc -l'                                 # Count files

# Modern search tools
alias search='rg --smart-case --pretty'                              # Smart case search with colors
alias searchall='rg --smart-case --hidden --no-ignore'               # Search hidden and ignored files
alias searchcode='rg --type-add "code:*.{rs,go,js,ts,py,rb,java,cpp,c,h}" --type code'  # Search only code files
alias rgi='rg -i -.'                                                 # Ripgrep with ignore case and in hidden files

# Git diff shortcuts that leverage delta
alias gd='git diff'                                                  # Quick git diff (uses delta)
alias gds='git diff --staged'                                        # Staged changes (uses delta)
alias gdh='git diff HEAD~1'                                          # Compare with previous commit

# Project context helpers
alias git-summary='echo "📊 Git Repository Summary:"; echo "Branch: $(git branch --show-current 2>/dev/null || echo "not a git repo")"; echo "Status:"; git status --porcelain 2>/dev/null | head -10 || echo "not a git repo"; echo "Recent commits:"; git log --oneline -5 2>/dev/null || echo "not a git repo"'  # Quick git repository overview

# AI context functions
function proj-context() {
    echo "📁 Project Context for: $(basename $(pwd))"
    echo "═══════════════════════════════════════"
    echo "📍 Location: $(pwd)"

    # Check for common project files
    for file in package.json Cargo.toml go.mod pyproject.toml requirements.txt Makefile README.md .env; do
        if [[ -f "$file" ]]; then
            echo "📄 Found: $file"
        fi
    done

    # Git info if available
    if git rev-parse --git-dir > /dev/null 2>&1; then
        echo "🌿 Git branch: $(git branch --show-current)"
        echo "📊 Git status: $(git status --porcelain | wc -l) changes"
    fi

    # Directory stats
    echo "📈 Directory stats:"
    echo "   Files: $(find . -type f -not -path '*/.*' | wc -l)"
    echo "   Directories: $(find . -type d -not -path '*/.*' | wc -l)"
    echo "   Size: $(du -sh . | cut -f1)"
}

# Quick documentation lookup
function docs() {
    if [[ $# -eq 0 ]]; then
        echo "Usage: docs <command>"
        echo "Quick documentation lookup"
        return 1
    fi

    case $1 in
        git) echo "📚 Git quick reference:"; echo "  git status, git add ., git commit -m 'msg', git push"; ;;
        docker) echo "📚 Docker quick reference:"; echo "  docker ps, docker build -t name ., docker run -it name"; ;;
        npm) echo "📚 NPM quick reference:"; echo "  npm install, npm run dev, npm run build, npm test"; ;;
        cargo) echo "📚 Cargo quick reference:"; echo "  cargo new, cargo build, cargo run, cargo test"; ;;
        *) man $1 2>/dev/null || echo "❌ No documentation found for: $1"; ;;
    esac
}

# JavaScript/Node.js tooling - prefer bun over npm
alias npm-install='bun install'
alias npm-run='bun run'
alias npm-exec='bunx'

# Package management shortcuts
alias pkg-install='bun install'  # Default to bun for new projects
alias pkg-global='bun install -g'  # Global package installation with bun

# Fallback aliases for npm when bun doesn't work
alias npm-fallback='command npm'
alias npx-fallback='command npx'

# Note: We keep npx available for MCP servers that need it

# Todo.txt - Unified task management
# PRIMARY: NeoVim plugin (<leader>tt = open, <leader>ta = add, <leader>td = done list)
# FALLBACK: CLI aliases below for quick terminal access
alias tl='echo "📝 Current todos (use <leader>tt in nvim for full interface):" && cat ~/todo.txt | rg -v "^x " | nl'  # Show current todos in terminal
# Quick add task function with priority support
function ta() {
    local priority=""
    local task="$*"

    # If no arguments provided, open NeoVim with done.txt and trigger capture_todo
    if [[ $# -eq 0 ]]; then
        echo "📝 Opening NeoVim todo interface..."
        nvim ~/done.txt -c "lua require('todotxt').capture_todo()"
        return
    fi

    # Check if first argument is A, B, or C for priority
    if [[ "$1" =~ ^[ABC]$ ]]; then
        priority="($1) "
        shift
        task="$*"
    fi

    echo "$(date +%Y-%m-%d) $priority$task" >> ~/todo.txt
    echo "Added: $priority$task"
    echo ""
    echo "Current todos:"
    cat ~/todo.txt | rg -v "^x " | nl
}
alias tt='nvim -c "lua require(\"todotxt\").toggle_todotxt()"'  # Open NeoVim with todo.txt buffer interface

# Quick NeoVim shortcuts
alias nv='nvim ./'  # Open current directory in NeoVim
alias hx='hx'  # Quick helix editor (lightweight alternative to nvim)

# Advanced CLI operations (todo.sh tool from Homebrew)
alias ta-cli='todo.sh add'                                      # CLI add: ta-cli "Call Mom"
alias tl-cli='todo.sh list | bat --paging=never --style=numbers' # CLI list with syntax highlighting
alias tp='todo.sh listproj | sort'                             # List projects (CLI)
alias tc='todo.sh listcon | sort'                              # List contexts (CLI)
alias ts='todo.sh list'                                        # Search tasks (CLI)

# Quick todo command reference
alias t='echo "📝 Todo.txt Commands Cheat Sheet:" && echo "===============================" && echo "" && echo "🎯 MAIN ACTIONS:" && echo "   ta <task>     - Add new task (with priority: ta \"Call Mom @home +family\")" && echo "   tl            - List current todos (terminal view)" && echo "   tt            - Open NeoVim todo interface" && echo "   td <num>      - Complete task by line number" && echo "" && echo "🔍 BROWSING (CLI):" && echo "   tl-cli        - List with syntax highlighting" && echo "   tp            - Show all projects (+project)" && echo "   tc            - Show all contexts (@context)" && echo "   ts            - Search/list tasks" && echo "   ta-cli        - Add task via CLI tool" && echo "" && echo "📊 OVERVIEW:" && echo "   todo-overview - Full stats and formatted view" && echo "" && echo "💡 Examples:" && echo "   ta \"Fix bug @work +project (A)\"  # High priority task" && echo "   ta \"Buy milk @errands\"          # Simple task with context" && echo "   td 3                            # Complete task #3"'  # Show all todo commands

# Enhanced viewing function for CLI use
function todo-overview() {
    echo "📋 Todo Overview:"
    echo "===================="
    todo.sh list | bat --paging=never --style=numbers --theme=Dracula
    echo ""
    echo "📊 Quick Stats:"
    echo "   Total tasks: $(todo.sh list | wc -l)"
    echo "   Projects: $(todo.sh listproj | wc -l)"
    echo "   Contexts: $(todo.sh listcon | wc -l)"
}

# Quick completion function for simple todo.txt format
function td() {
    if [[ $# -eq 0 ]]; then
        echo "Usage: td [task_number]  - Mark task as done"
        echo "Current tasks:"
        cat ~/todo.txt | rg -v "^x " | nl
        return
    fi

    local line_num=$1
    local total_lines=$(cat ~/todo.txt | rg -v "^x " | wc -l)

    if [[ $line_num -gt $total_lines ]] || [[ $line_num -lt 1 ]]; then
        echo "❌ Task number $line_num not found (1-$total_lines)"
        return 1
    fi

    # Get the actual line from active todos (non-completed)
    local task_line=$(cat ~/todo.txt | rg -v "^x " | sed -n "${line_num}p")

    # Mark as completed with completion date
    local completed_task="x $(date +%Y-%m-%d) $task_line"

    # Create temp file with completed task and remaining tasks
    {
        cat ~/todo.txt | rg "^x "  # Keep existing completed tasks
        echo "$completed_task"       # Add newly completed task
        cat ~/todo.txt | rg -v "^x " | sed "${line_num}d"  # Remove completed task from active
    } > ~/todo.txt.tmp && mv ~/todo.txt.tmp ~/todo.txt

    echo "✅ Completed: $task_line"
    echo ""
    echo "Remaining tasks:"
    cat ~/todo.txt | rg -v "^x " | nl
}

# Dotfiles health check function
function dotfiles-health() {
    echo "🏥 Dotfiles Health Check"
    echo "═══════════════════════"
    echo "📍 Location: ~/dotfiles"
    echo ""

    echo "🔧 Core Tools:"
    echo "  Homebrew: $(brew --version | head -1)"
    echo "  Git: $(git --version)"
    echo "  NeoVim: $(nvim --version | head -1)"
    echo ""

    echo "🚀 Language Runtimes:"
    echo "  Node.js: $(node --version 2>/dev/null || echo "❌ not available")"
    echo "  Bun: $(bun --version 2>/dev/null || echo "❌ not available")"
    echo "  Go: $(go version 2>/dev/null | cut -d" " -f3 || echo "❌ not available")"
    echo "  Rust: $(rustc --version 2>/dev/null | cut -d" " -f2 || echo "❌ not available")"
    echo "  Python: $(python3 --version 2>/dev/null || echo "❌ not available")"
    echo ""

    echo "⚡ Modern Tools:"
    echo "  mise: $(mise --version 2>/dev/null || echo "❌ not available")"
    echo "  delta: $(delta --version 2>/dev/null || echo "❌ not available")"
    echo "  eza: $(eza --version 2>/dev/null | head -1 || echo "❌ not available")"
    echo "  bat: $(bat --version 2>/dev/null || echo "❌ not available")"
    echo ""

    echo "📦 Package Status:"
    echo "  Brewfile packages: $(rg -c '^brew|^tap|^cask' ~/dotfiles/Brewfile || echo 0)"
    echo "  Symlinks active: $(ls -la ~ | rg -c dotfiles || echo 0)"
    echo ""
    echo "✨ Environment ready!"
}


# AI Context Helper - Provides comprehensive context to new Claude Code instances
ai-context() {
    echo "🤖 AI Context Setup for New Claude Code Instance"
    echo "════════════════════════════════════════════════"
    echo ""

    echo "⏰ Current Date/Time: $(date)"
    echo "🔧 Shell Config Loaded: $(date -r $ZSHRC_LOADED 2>/dev/null || echo 'Unknown')"
    echo "   • ZSHRC_LOADED timestamp: $ZSHRC_LOADED"
    echo ""

    echo "⚠️  CRITICAL ENVIRONMENT NOTES:"
    echo "   • AI agents should prefer 'rg' (ripgrep) over 'grep' for better performance"
    echo "   • Use 'rg' syntax, not POSIX grep syntax (e.g., 'rg pattern' not 'grep -r pattern')"
    echo "   • Both grep and rg are available with their native behaviors"
    echo ""

    echo "📁 Current Environment:"
    env-info
    echo ""

    echo "🔧 Project Context:"
    proj-context
    echo ""

    echo "📊 Repository Status:"
    git-summary
    echo ""

    echo "📋 REQUIRED AI ACTIONS:"
    echo "────────────────────────"

    # Check for local CLAUDE.md
    if [[ -f "CLAUDE.md" ]]; then
        echo "1. 🔍 READ LOCAL PROJECT CONTEXT:"
        echo "   Use: Read tool to read './CLAUDE.md' completely"
        echo "   This contains project-specific instructions and architecture"
        echo ""
    else
        echo "1. ⚠️  NO LOCAL CLAUDE.MD FOUND:"
        echo "   Consider running: claude init"
        echo "   This creates a project-specific CLAUDE.md with context"
        echo "   Or create manually if this project needs AI context documentation"
        echo ""
    fi

    echo "2. 🌐 READ GLOBAL DEVELOPMENT CONTEXT:"
    echo "   Use: Read tool to read '~/.config/claude/CLAUDE.md' completely"
    echo "   This contains Ollie's development preferences and AI collaboration style"
    echo ""

    echo "3. 🛠️  VALIDATE ENVIRONMENT:"
    echo "   Run: dotfiles-health"
    echo "   Confirms all tools and configurations are working properly"
    echo ""

    echo "4. 🔍 DISCOVER AVAILABLE TOOLS:"
    echo "   Run: alias | rg <pattern>"
    echo "   Explore available shortcuts and productivity commands"
    echo ""

    echo "💡 REMEMBER:"
    echo "   • Use 'rg' instead of 'grep' for better performance and modern UX"
    echo "   • Read both CLAUDE.md files for complete context"
    echo "   • Use env-info, proj-context, git-summary for dynamic updates"
    echo "   • This environment prioritizes modern tooling and AI-first workflows"
}

# Secrets Management
# Lazily load the Gemini API key from 1Password on first use
gemini() {
  if [[ -z "$GEMINI_API_KEY" ]]; then
    export GEMINI_API_KEY=$(op read "op://Private/gemini_api_key/credential" --account my.1password.com)
  fi
  command gemini "$@"
}

# 1Password Diagnostic - Capture what's triggering 1Password popups
alias 1p-debug='echo "🔍 Capturing processes that might trigger 1Password..." && ps aux | rg "git|ssh|op " | rg -v "rg |1Password\.app" && echo "" && echo "💡 Last command: $(fc -ln -1)" && echo "📋 Saved to /tmp/1p-trigger.log" && ps aux | rg "git|ssh|op " | rg -v "rg |1Password\.app" > /tmp/1p-trigger.log'  # Diagnose 1Password authentication triggers
